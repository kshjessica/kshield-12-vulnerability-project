import os

from django.contrib.auth import login
from django.http import HttpResponse
from django.shortcuts import get_object_or_404, redirect, render
from django.http import HttpResponse
from .func import sqlInjection, xss1, xss_filter, xss_filter2, textfilter, textfilter2

from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.clickjacking import xframe_options_exempt
from .forms import CustomUserCreationForm
from .models import AttackingQuestion, SecureCodingQuestion
from enum import Enum
import urllib


class vulnType(Enum):
    SQL_INJECTION = "sql-injection"
    XSS = "xss"
    XSS_FILTER = "xss-filter"
    XSS_FILTER2 = "xss-filter2"
    CSRF = "csrf"
    SSRF = "ssrf"
    FILE_UPLOAD = "file-upload"
    FILE_DOWNLOAD = "file-download"
    ETC = "etc"


class solveType(Enum):
    SOLVE = 0
    WRONG = 1
    UNSOLVE = 2


# file download 공격을 위한 BASE_DIR
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# csrf 공격을 위한 세션 저장소
session_storage = {"admin_session_id": "admin"}
users = {"guest": "guest", "admin": "admin_password"}


def index(request):
    return render(request, "landing.html")


def signup(request):
    if request.method == "POST":
        form = CustomUserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            return redirect("index")
    else:
        form = CustomUserCreationForm()
    return render(request, "registration/signup.html", {"form": form})


def about(request):
    return render(request, "header/about.html")


def how_to_play(request):
    return render(request, "header/how_to_play.html")


def qna(request):
    return render(request, "header/qna.html")


def question_list(request):
    attacking_questions = AttackingQuestion.objects.all()
    secure_coding_questions = SecureCodingQuestion.objects.all()
    return render(
        request,
        "solve/question_list.html",
        {
            "attacking_questions": attacking_questions,
            "secure_coding_questions": secure_coding_questions,
        },
    )

@csrf_exempt
def attacking(request, type):
    successful = False
    unsuccessful = False
    question = get_object_or_404(AttackingQuestion, type=type)
    if(type == vulnType.SQL_INJECTION.value):
        successful, question = sqlInjection(request, question)
    elif(type == vulnType.XSS.value):
        successful, question = xss1(request, question)
    elif(type == vulnType.XSS_FILTER.value):
        successful, question = xss_filter(request, question)
    elif(type == vulnType.XSS_FILTER2.value):
        successful, question = xss_filter2(request, question)
    elif type == "file-download":
        if request.method == "GET": 
            file_path = request.GET.get("file")
            if file_path:
                try:
                    if file_path == "../../../../../../../../etc/passwd":
                        modified_path = "etc/passwd"
                        full_path = os.path.join(BASE_DIR, "uploads", modified_path)
                        uploads_dir = os.path.abspath(os.path.join(BASE_DIR, "uploads"))
                        full_path = os.path.abspath(full_path)

                        if os.path.commonpath([uploads_dir]) == os.path.commonpath(
                            [uploads_dir, full_path]
                        ) and os.path.exists(full_path):
                            successful = True
                            question.status = "풀이 완료"
                            question.save()

                            # TODO: 파일 다운로드 기능 구현
                            """
                            with open(full_path, "rb") as f:
                                response = HttpResponse(
                                    f.read(), content_type="application/octet-stream"
                                )
                                response["Content-Disposition"] = (
                                    f'attachment; filename="{os.path.basename(full_path)}"'
                                )
                            return response
                            """
                        else:
                            print("File does not exist or invalid path.")
                            unsuccessful = True
                    else:
                        unsuccessful = True
                except Exception as e:
                    print(f"Download failed: {e}")
                    unsuccessful = True
            else:
                print("No file path provided.")
    elif type == "csrf":
        if request.method == "GET":
            payload = request.GET.get("payload", "")
            if payload:
                if '<img src="/change_password?pw=' in payload:
                    start = payload.find('<img src="/change_password?pw=') + len(
                        '<img src="/change_password?pw='
                    )
                    end = payload.find('">', start)
                    new_password = payload[start:end]

                    session_id = "admin_session_id"
                    try:
                        username = session_storage[session_id]
                        if username == "admin":
                            users["admin"] = new_password
                            successful = True
                            question.status = "풀이 완료"
                            question.save()
                        else:
                            unsuccessful = True
                    except KeyError:
                        unsuccessful = True
                else:
                    unsuccessful = True
    return render(
        request,
        f"solve/attacking-practice/{type}/question.html",
        {
            "successful": successful,
            "unsuccessful": unsuccessful,
            "hint": question.hint,
            "status": question.status,
            "type": type,
        },
    )

def xss_vuln(request):
    param = request.GET.get('param', '')
    return HttpResponse(f"Vulnerable page with param: {param}")

def xss_vuln_filter(request):
    param = request.GET.get('param', '')
    param = textfilter(param)
    print(param)
    return HttpResponse(f"Vulnerable page with param: {param}")

@xframe_options_exempt
def xss_vuln_filter2(request):
    param = request.GET.get('param', '')
    param = textfilter2(param)

    text = urllib.parse.unquote(param)
    print(text)
    return HttpResponse(f"Vulnerable page with param: {param}")

def attacking_explanation(request, type):
    question = get_object_or_404(AttackingQuestion, type=type)

    if type == "sql-injection":
        query = (
            type
            + "(n)"
            + "SELECT * FROM user_data WHERE first_name = 'John' AND last_name = 'Smith'"
        )

    elif type == "file-download":
        query = type + "(n)" + "../../../../../../../../etc/passwd"

    elif type == "csrf":
        query = type + "(n)" + '<img src="/change_password?pw=admin"/>'

    context = {"correct": True, "question": question, "query": query}

    return render(request, f"solve/attacking-practice/{type}/explanation.html", context)


def secure_coding(request, type):
    successful = False
    unsuccessful = False

    question = get_object_or_404(SecureCodingQuestion, type=type)

    if request.method == "POST":
        user_answer = request.POST.get("answer")
        if user_answer.strip() == question.correct_answer.strip():
            successful = True
            print("성공")
            question.status = "풀이 완료"
            question.save()
        else:
            unsuccessful = True
    

    return render(
        request,
        f"solve/secure-coding-practice/{type}/question.html",
        {
            "successful": successful,
            "unsuccessful": unsuccessful,
            "title": question.title,
            "content": question.content,
            "hint": question.hint,
            "correct_answer": question.correct_answer,
            "status": question.status,
            "type": type,
        },
    )


def secure_coding_explanation(request, type):
    question = get_object_or_404(SecureCodingQuestion, type=type)

    query = type + "(n)" + question.correct_answer

    context = {"correct": True, "question": question, "query": query}

    return render(
        request, f"solve/secure-coding-practice/{type}/explanation.html", context
    )
